exports["Lite"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__geom_mat4__ = __webpack_require__(1);


class Group {
  constructor() {
    this.x = 0;
    this.y = 0;
    this.width = 0;
    this.height = 0;
    
    this.children = [];
    this.transform = new __WEBPACK_IMPORTED_MODULE_0__geom_mat4__["a" /* default */]();
  }
  
  add(child) {
    this.children.indexOf(child) === -1 ? this.children.push(child) : ``;
    
    this.refreshDimensions();
  }
  
  refreshDimensions() {
    const children = this.children;
    let minX = Number.MAX_SAFE_INTEGER;
    let maxX = Number.MIN_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    
    for (let i = 0, l = children.length, child; i < l; i++) {
      child = children[i];
      
      minX = child.x < minX ? child.x : minX;
      maxX = child.x > maxX ? child.x : maxX;
      minY = child.y < minY ? child.y : minY;
      maxY = child.y > maxY ? child.y : maxY;
    }
    
    this.width = maxX - minX;
    this.height = maxY - minY;
  }
  
  update() {
    const children = this.children;
    
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].update();
    }
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Group;



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/*
* 0,  1,  2,  3,
* 4,  5,  6,  7,
* 8,  9,  10, 11,
* 12, 13, 14, 15
* */

class Mat4 extends Float32Array {
  constructor() {
    super(16);
    this.identity();
  }

  identity() {
    const t = this;
    t[0] = t[5] = t[10] = t[15] = 1;
    t[1] = t[2] = t[3] = t[4] = t[6] = t[7] = t[8] = t[9] = t[11] = t[12] = t[13] = t[14] = 0;
  }

  setCanvasProjection(w, h) {
    const t = this;
    
    t[0] = 2 / w;
    t[5] = -2 / h;
    t[12] = -w / 2;
    t[13] = h / 2;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Mat4;



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__group__ = __webpack_require__(0);


class Sprite extends __WEBPACK_IMPORTED_MODULE_0__group__["a" /* default */] {
  constructor(texture, frameName) {
    super();
    
    this.texture = texture;
    this.frameName = frameName;
    
    this.x = this.left = 0;
    this.y = this.top = 0;
    this.width = this.right = texture.width;
    this.height = this.bottom = texture.height;

    // [x, y, tex]
    // worldTransform zIndex

    const frame = this.frame = texture.atlas.frames.filter(f => f.filename === frameName)[0].frame; // todo awesome
    const texW = texture.image.width;
    const texH = texture.image.height;
    
    this.texCoord = {
      l: frame.x / texW, 
      r: (frame.x + frame.w) / texW, 
      t: frame.y / texH, 
      b: (frame.y + frame.h) / texH
    };
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Sprite;


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Texture {
  constructor(image, atlas) {
    this.image = image;
    this.atlas = atlas;
  }  
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Texture;



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__programManager_chuncks_standard_vert__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__programManager_chuncks_standard_vert___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__programManager_chuncks_standard_vert__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__programManager_chuncks_standard_frag__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__programManager_chuncks_standard_frag___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__programManager_chuncks_standard_frag__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__programManager_program__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__programManager_tex__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__geom_mat4__ = __webpack_require__(1);






class Renderer {
  constructor(el) {
    const gl = this.gl = el.getContext(`webgl`);
    gl.viewport(0, 0, el.width, el.height);
    gl.clearColor(0, 0, 0, 1);
    
    const program = this.program = new __WEBPACK_IMPORTED_MODULE_2__programManager_program__["a" /* default */](gl, __WEBPACK_IMPORTED_MODULE_0__programManager_chuncks_standard_vert___default.a, __WEBPACK_IMPORTED_MODULE_1__programManager_chuncks_standard_frag___default.a);
    this.tex = new __WEBPACK_IMPORTED_MODULE_3__programManager_tex__["a" /* default */](gl);
    
    gl.uniformMatrix4fv(gl.getUniformLocation(program.native, `uProjectionMatrix`), 
      false, new __WEBPACK_IMPORTED_MODULE_4__geom_mat4__["a" /* default */]().setCanvasProjection(el.width, el.height));
  }

  render(world) {
    const gl = this.gl;
    const tex = this.tex;
    const program = this.program;
    const buffer = program.buffer;
    const objects = world.children;
    
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    buffer.clear();

    for (let i = 0, l = objects.length, texSlot; i < l; i++) {
      // assign program to objects then sort for batches
      // if no mask or filter use standard shaders
      // invoke setProgram of program manager to use or create and then use program 
            
      texSlot = tex.bind(objects[i].texture);
      buffer.concat(objects[i], i, texSlot);
    }
    
    program.prepare();
    
    gl.drawArrays(gl.TRIANGLES, 0, buffer.vertices);
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Renderer;



/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = "precision highp float;\r\n\r\nvarying vec2 vTexCoord;\r\nvarying int vTexSlot;\r\n\r\nuniform sampler2D uSamplers[8];\r\n\r\nvoid main(){\r\n    gl_FragColor = texture2D(uSamplers[vTexSlot], vTexCoord);\r\n}\r\n"

/***/ }),
/* 6 */
/***/ (function(module, exports) {

module.exports = "attribute vec3 aPosition;\r\nattribute vec2 aTexCoord;\r\nattribute int aTexSlot;\r\n\r\nuniform mat4 uProjectionMatrix;\r\n\r\nvarying vec2 vTexCoord;\r\nvarying int vTexSlot;\r\n\r\nvoid main(){\r\n    gl_Position = uProjectionMatrix * vec4(aPosition, 1.0);\r\n    vTexCoord = aTexCoord;\r\n    vTexSlot = aTexSlot;\r\n}\r\n"

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__renderer__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__display_group__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__display_sprite__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__graphic_texture__ = __webpack_require__(3);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return __WEBPACK_IMPORTED_MODULE_2__display_sprite__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return __WEBPACK_IMPORTED_MODULE_1__display_group__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Renderer", function() { return __WEBPACK_IMPORTED_MODULE_0__renderer__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return __WEBPACK_IMPORTED_MODULE_3__graphic_texture__["a"]; });








/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Buffer extends Float32Array {
  constructor() {
    super(512);
    this.size = 0;
    this.vertices = 0;
  }
  
  concat(object, z, s) {
    const t = this;
    const texCoord = object.texCoord;
    let size = this.size;

    // left top
    t[size++] = object.x;
    t[size++] = object.y;
    t[size++] = z;
    t[size++] = texCoord.l;
    t[size++] = texCoord.t;
    t[size++] = s;

    // right bottom
    t[size++] = object.right;
    t[size++] = object.bottom;
    t[size++] = z;
    t[size++] = texCoord.r;
    t[size++] = texCoord.b;
    t[size++] = s;

    // left bottom
    t[size++] = object.left;
    t[size++] = object.bottom;
    t[size++] = z;
    t[size++] = texCoord.l;
    t[size++] = texCoord.b;
    t[size++] = s;


    // left top
    t[size++] = object.x;
    t[size++] = object.y;
    t[size++] = z;
    t[size++] = texCoord.l;
    t[size++] = texCoord.t;
    t[size++] = s;

    // right bottom
    t[size++] = object.right;
    t[size++] = object.bottom;
    t[size++] = z;
    t[size++] = texCoord.r;
    t[size++] = texCoord.b;
    t[size++] = s;
    
    // right top
    t[size++] = object.right;
    t[size++] = object.top;
    t[size++] = z;
    t[size++] = texCoord.r;
    t[size++] = texCoord.t;
    t[size++] = s;

    this.size = size;
    this.vertices += 6;
  }
  
  clear() {
    this.size = 0;
    this.vertices = 0;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Buffer;



/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__buffer__ = __webpack_require__(8);


class Program {
  constructor(gl, vertexSource, fragmentSource) {
    const vertexShader = gl.createShader(gl.VERTEX_SHADER);
    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(vertexShader, vertexSource);
    gl.shaderSource(fragmentShader, fragmentSource);
    gl.compileShader(vertexShader);
    gl.compileShader(fragmentShader);
    const program = this.native = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);

    this.buffer = new __WEBPACK_IMPORTED_MODULE_0__buffer__["a" /* default */]();
  }

  prepare() {
    const gl = this.gl;
    const buffer = gl.createBuffer(); // maybe it doesn't need to create it every time
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer); // don't bind if bound?
    gl.bufferData(gl.ARRAY_BUFFER, this.buffer, gl.STATIC_DRAW); // maybe dynamic and sub data is quicker
    gl.useProgram(this.native); // todo program manager should check current program is used already
    // wtf
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Program;



/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
class Tex {
  constructor(gl) {
    this.gl = gl;
    this.slots = [null, null, null, null, null, null, null, null];
  }

  bind(texture) {
    const slots = this.slots;
    let index = slots.indexOf(texture);

    if (index === -1) {
      index = slots.indexOf(null);
      slots[index] = texture;
      
      const gl = this.gl;
      const tex = gl.createTexture();
      gl.activeTexture(gl[`TEXTURE${index}`]);
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
    }

    return index;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = Tex;



/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGl0ZS5taW4uanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZTE0MzBiMjFhOTMxOTM1ZTQyYTgiLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheS9ncm91cC5qcyIsIndlYnBhY2s6Ly8vLi9nZW9tL21hdDQuanMiLCJ3ZWJwYWNrOi8vLy4vZGlzcGxheS9zcHJpdGUuanMiLCJ3ZWJwYWNrOi8vLy4vZ3JhcGhpYy90ZXh0dXJlLmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL3JlbmRlcmVyL3Byb2dyYW1NYW5hZ2VyL2NodW5ja3Mvc3RhbmRhcmQuZnJhZyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci9jaHVuY2tzL3N0YW5kYXJkLnZlcnQiLCJ3ZWJwYWNrOi8vLy4vbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci9idWZmZXIuanMiLCJ3ZWJwYWNrOi8vLy4vcmVuZGVyZXIvcHJvZ3JhbU1hbmFnZXIvcHJvZ3JhbS5qcyIsIndlYnBhY2s6Ly8vLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci90ZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gaWRlbnRpdHkgZnVuY3Rpb24gZm9yIGNhbGxpbmcgaGFybW9ueSBpbXBvcnRzIHdpdGggdGhlIGNvcnJlY3QgY29udGV4dFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5pID0gZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHZhbHVlOyB9O1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA3KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCBlMTQzMGIyMWE5MzE5MzVlNDJhOCIsImltcG9ydCBNYXQ0IGZyb20gJy4uL2dlb20vbWF0NCc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcm91cCB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnggPSAwO1xyXG4gICAgdGhpcy55ID0gMDtcclxuICAgIHRoaXMud2lkdGggPSAwO1xyXG4gICAgdGhpcy5oZWlnaHQgPSAwO1xyXG4gICAgXHJcbiAgICB0aGlzLmNoaWxkcmVuID0gW107XHJcbiAgICB0aGlzLnRyYW5zZm9ybSA9IG5ldyBNYXQ0KCk7XHJcbiAgfVxyXG4gIFxyXG4gIGFkZChjaGlsZCkge1xyXG4gICAgdGhpcy5jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA9PT0gLTEgPyB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpIDogYGA7XHJcbiAgICBcclxuICAgIHRoaXMucmVmcmVzaERpbWVuc2lvbnMoKTtcclxuICB9XHJcbiAgXHJcbiAgcmVmcmVzaERpbWVuc2lvbnMoKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICBsZXQgbWluWCA9IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSO1xyXG4gICAgbGV0IG1heFggPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUjtcclxuICAgIGxldCBtaW5ZID0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XHJcbiAgICBsZXQgbWF4WSA9IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSO1xyXG4gICAgXHJcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aCwgY2hpbGQ7IGkgPCBsOyBpKyspIHtcclxuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcclxuICAgICAgXHJcbiAgICAgIG1pblggPSBjaGlsZC54IDwgbWluWCA/IGNoaWxkLnggOiBtaW5YO1xyXG4gICAgICBtYXhYID0gY2hpbGQueCA+IG1heFggPyBjaGlsZC54IDogbWF4WDtcclxuICAgICAgbWluWSA9IGNoaWxkLnkgPCBtaW5ZID8gY2hpbGQueSA6IG1pblk7XHJcbiAgICAgIG1heFkgPSBjaGlsZC55ID4gbWF4WSA/IGNoaWxkLnkgOiBtYXhZO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLndpZHRoID0gbWF4WCAtIG1pblg7XHJcbiAgICB0aGlzLmhlaWdodCA9IG1heFkgLSBtaW5ZO1xyXG4gIH1cclxuICBcclxuICB1cGRhdGUoKSB7XHJcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XHJcbiAgICBcclxuICAgIGZvciAobGV0IGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgIGNoaWxkcmVuW2ldLnVwZGF0ZSgpO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3BsYXkvZ3JvdXAuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLypcclxuKiAwLCAgMSwgIDIsICAzLFxyXG4qIDQsICA1LCAgNiwgIDcsXHJcbiogOCwgIDksICAxMCwgMTEsXHJcbiogMTIsIDEzLCAxNCwgMTVcclxuKiAqL1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWF0NCBleHRlbmRzIEZsb2F0MzJBcnJheSB7XHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigxNik7XHJcbiAgICB0aGlzLmlkZW50aXR5KCk7XHJcbiAgfVxyXG5cclxuICBpZGVudGl0eSgpIHtcclxuICAgIGNvbnN0IHQgPSB0aGlzO1xyXG4gICAgdFswXSA9IHRbNV0gPSB0WzEwXSA9IHRbMTVdID0gMTtcclxuICAgIHRbMV0gPSB0WzJdID0gdFszXSA9IHRbNF0gPSB0WzZdID0gdFs3XSA9IHRbOF0gPSB0WzldID0gdFsxMV0gPSB0WzEyXSA9IHRbMTNdID0gdFsxNF0gPSAwO1xyXG4gIH1cclxuXHJcbiAgc2V0Q2FudmFzUHJvamVjdGlvbih3LCBoKSB7XHJcbiAgICBjb25zdCB0ID0gdGhpcztcclxuICAgIFxyXG4gICAgdFswXSA9IDIgLyB3O1xyXG4gICAgdFs1XSA9IC0yIC8gaDtcclxuICAgIHRbMTJdID0gLXcgLyAyO1xyXG4gICAgdFsxM10gPSBoIC8gMjtcclxuICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9nZW9tL21hdDQuanNcbi8vIG1vZHVsZSBpZCA9IDFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEdyb3VwIGZyb20gJy4vZ3JvdXAnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3ByaXRlIGV4dGVuZHMgR3JvdXAge1xyXG4gIGNvbnN0cnVjdG9yKHRleHR1cmUsIGZyYW1lTmFtZSkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIFxyXG4gICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcclxuICAgIHRoaXMuZnJhbWVOYW1lID0gZnJhbWVOYW1lO1xyXG4gICAgXHJcbiAgICB0aGlzLnggPSB0aGlzLmxlZnQgPSAwO1xyXG4gICAgdGhpcy55ID0gdGhpcy50b3AgPSAwO1xyXG4gICAgdGhpcy53aWR0aCA9IHRoaXMucmlnaHQgPSB0ZXh0dXJlLndpZHRoO1xyXG4gICAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdHRvbSA9IHRleHR1cmUuaGVpZ2h0O1xyXG5cclxuICAgIC8vIFt4LCB5LCB0ZXhdXHJcbiAgICAvLyB3b3JsZFRyYW5zZm9ybSB6SW5kZXhcclxuXHJcbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuZnJhbWUgPSB0ZXh0dXJlLmF0bGFzLmZyYW1lcy5maWx0ZXIoZiA9PiBmLmZpbGVuYW1lID09PSBmcmFtZU5hbWUpWzBdLmZyYW1lOyAvLyB0b2RvIGF3ZXNvbWVcclxuICAgIGNvbnN0IHRleFcgPSB0ZXh0dXJlLmltYWdlLndpZHRoO1xyXG4gICAgY29uc3QgdGV4SCA9IHRleHR1cmUuaW1hZ2UuaGVpZ2h0O1xyXG4gICAgXHJcbiAgICB0aGlzLnRleENvb3JkID0ge1xyXG4gICAgICBsOiBmcmFtZS54IC8gdGV4VywgXHJcbiAgICAgIHI6IChmcmFtZS54ICsgZnJhbWUudykgLyB0ZXhXLCBcclxuICAgICAgdDogZnJhbWUueSAvIHRleEgsIFxyXG4gICAgICBiOiAoZnJhbWUueSArIGZyYW1lLmgpIC8gdGV4SFxyXG4gICAgfTtcclxuICB9XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2Rpc3BsYXkvc3ByaXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleHR1cmUge1xyXG4gIGNvbnN0cnVjdG9yKGltYWdlLCBhdGxhcykge1xyXG4gICAgdGhpcy5pbWFnZSA9IGltYWdlO1xyXG4gICAgdGhpcy5hdGxhcyA9IGF0bGFzO1xyXG4gIH0gIFxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vZ3JhcGhpYy90ZXh0dXJlLmpzXG4vLyBtb2R1bGUgaWQgPSAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB2ZXJ0ZXhTb3VyY2UgZnJvbSAnLi9wcm9ncmFtTWFuYWdlci9jaHVuY2tzL3N0YW5kYXJkLnZlcnQnO1xyXG5pbXBvcnQgZnJhZ21lbnRTb3VyY2UgZnJvbSAnLi9wcm9ncmFtTWFuYWdlci9jaHVuY2tzL3N0YW5kYXJkLmZyYWcnO1xyXG5pbXBvcnQgUHJvZ3JhbSBmcm9tICcuL3Byb2dyYW1NYW5hZ2VyL3Byb2dyYW0nO1xyXG5pbXBvcnQgVGV4IGZyb20gJy4vcHJvZ3JhbU1hbmFnZXIvdGV4JztcclxuaW1wb3J0IE1hdDQgZnJvbSAnLi4vZ2VvbS9tYXQ0JztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlbmRlcmVyIHtcclxuICBjb25zdHJ1Y3RvcihlbCkge1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsID0gZWwuZ2V0Q29udGV4dChgd2ViZ2xgKTtcclxuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGVsLndpZHRoLCBlbC5oZWlnaHQpO1xyXG4gICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAxKTtcclxuICAgIFxyXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMucHJvZ3JhbSA9IG5ldyBQcm9ncmFtKGdsLCB2ZXJ0ZXhTb3VyY2UsIGZyYWdtZW50U291cmNlKTtcclxuICAgIHRoaXMudGV4ID0gbmV3IFRleChnbCk7XHJcbiAgICBcclxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0ubmF0aXZlLCBgdVByb2plY3Rpb25NYXRyaXhgKSwgXHJcbiAgICAgIGZhbHNlLCBuZXcgTWF0NCgpLnNldENhbnZhc1Byb2plY3Rpb24oZWwud2lkdGgsIGVsLmhlaWdodCkpO1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKHdvcmxkKSB7XHJcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICBjb25zdCB0ZXggPSB0aGlzLnRleDtcclxuICAgIGNvbnN0IHByb2dyYW0gPSB0aGlzLnByb2dyYW07XHJcbiAgICBjb25zdCBidWZmZXIgPSBwcm9ncmFtLmJ1ZmZlcjtcclxuICAgIGNvbnN0IG9iamVjdHMgPSB3b3JsZC5jaGlsZHJlbjtcclxuICAgIFxyXG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQpO1xyXG4gICAgYnVmZmVyLmNsZWFyKCk7XHJcblxyXG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aCwgdGV4U2xvdDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAvLyBhc3NpZ24gcHJvZ3JhbSB0byBvYmplY3RzIHRoZW4gc29ydCBmb3IgYmF0Y2hlc1xyXG4gICAgICAvLyBpZiBubyBtYXNrIG9yIGZpbHRlciB1c2Ugc3RhbmRhcmQgc2hhZGVyc1xyXG4gICAgICAvLyBpbnZva2Ugc2V0UHJvZ3JhbSBvZiBwcm9ncmFtIG1hbmFnZXIgdG8gdXNlIG9yIGNyZWF0ZSBhbmQgdGhlbiB1c2UgcHJvZ3JhbSBcclxuICAgICAgICAgICAgXHJcbiAgICAgIHRleFNsb3QgPSB0ZXguYmluZChvYmplY3RzW2ldLnRleHR1cmUpO1xyXG4gICAgICBidWZmZXIuY29uY2F0KG9iamVjdHNbaV0sIGksIHRleFNsb3QpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBwcm9ncmFtLnByZXBhcmUoKTtcclxuICAgIFxyXG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIGJ1ZmZlci52ZXJ0aWNlcyk7XHJcbiAgfVxyXG59XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVuZGVyZXIvaW5kZXguanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcInByZWNpc2lvbiBoaWdocCBmbG9hdDtcXHJcXG5cXHJcXG52YXJ5aW5nIHZlYzIgdlRleENvb3JkO1xcclxcbnZhcnlpbmcgaW50IHZUZXhTbG90O1xcclxcblxcclxcbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyc1s4XTtcXHJcXG5cXHJcXG52b2lkIG1haW4oKXtcXHJcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyc1t2VGV4U2xvdF0sIHZUZXhDb29yZCk7XFxyXFxufVxcclxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci9jaHVuY2tzL3N0YW5kYXJkLmZyYWdcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcImF0dHJpYnV0ZSB2ZWMzIGFQb3NpdGlvbjtcXHJcXG5hdHRyaWJ1dGUgdmVjMiBhVGV4Q29vcmQ7XFxyXFxuYXR0cmlidXRlIGludCBhVGV4U2xvdDtcXHJcXG5cXHJcXG51bmlmb3JtIG1hdDQgdVByb2plY3Rpb25NYXRyaXg7XFxyXFxuXFxyXFxudmFyeWluZyB2ZWMyIHZUZXhDb29yZDtcXHJcXG52YXJ5aW5nIGludCB2VGV4U2xvdDtcXHJcXG5cXHJcXG52b2lkIG1haW4oKXtcXHJcXG4gICAgZ2xfUG9zaXRpb24gPSB1UHJvamVjdGlvbk1hdHJpeCAqIHZlYzQoYVBvc2l0aW9uLCAxLjApO1xcclxcbiAgICB2VGV4Q29vcmQgPSBhVGV4Q29vcmQ7XFxyXFxuICAgIHZUZXhTbG90ID0gYVRleFNsb3Q7XFxyXFxufVxcclxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci9jaHVuY2tzL3N0YW5kYXJkLnZlcnRcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFJlbmRlcmVyIGZyb20gJy4vcmVuZGVyZXInO1xyXG5pbXBvcnQgR3JvdXAgZnJvbSAnLi9kaXNwbGF5L2dyb3VwJztcclxuaW1wb3J0IFNwcml0ZSBmcm9tICcuL2Rpc3BsYXkvc3ByaXRlJztcclxuaW1wb3J0IFRleHR1cmUgZnJvbSAnLi9ncmFwaGljL3RleHR1cmUnO1xyXG5cclxuZXhwb3J0IHtTcHJpdGUsIEdyb3VwLCBSZW5kZXJlciwgVGV4dHVyZX07XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbWFpbi5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBCdWZmZXIgZXh0ZW5kcyBGbG9hdDMyQXJyYXkge1xyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoNTEyKTtcclxuICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB0aGlzLnZlcnRpY2VzID0gMDtcclxuICB9XHJcbiAgXHJcbiAgY29uY2F0KG9iamVjdCwgeiwgcykge1xyXG4gICAgY29uc3QgdCA9IHRoaXM7XHJcbiAgICBjb25zdCB0ZXhDb29yZCA9IG9iamVjdC50ZXhDb29yZDtcclxuICAgIGxldCBzaXplID0gdGhpcy5zaXplO1xyXG5cclxuICAgIC8vIGxlZnQgdG9wXHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QueDtcclxuICAgIHRbc2l6ZSsrXSA9IG9iamVjdC55O1xyXG4gICAgdFtzaXplKytdID0gejtcclxuICAgIHRbc2l6ZSsrXSA9IHRleENvb3JkLmw7XHJcbiAgICB0W3NpemUrK10gPSB0ZXhDb29yZC50O1xyXG4gICAgdFtzaXplKytdID0gcztcclxuXHJcbiAgICAvLyByaWdodCBib3R0b21cclxuICAgIHRbc2l6ZSsrXSA9IG9iamVjdC5yaWdodDtcclxuICAgIHRbc2l6ZSsrXSA9IG9iamVjdC5ib3R0b207XHJcbiAgICB0W3NpemUrK10gPSB6O1xyXG4gICAgdFtzaXplKytdID0gdGV4Q29vcmQucjtcclxuICAgIHRbc2l6ZSsrXSA9IHRleENvb3JkLmI7XHJcbiAgICB0W3NpemUrK10gPSBzO1xyXG5cclxuICAgIC8vIGxlZnQgYm90dG9tXHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QubGVmdDtcclxuICAgIHRbc2l6ZSsrXSA9IG9iamVjdC5ib3R0b207XHJcbiAgICB0W3NpemUrK10gPSB6O1xyXG4gICAgdFtzaXplKytdID0gdGV4Q29vcmQubDtcclxuICAgIHRbc2l6ZSsrXSA9IHRleENvb3JkLmI7XHJcbiAgICB0W3NpemUrK10gPSBzO1xyXG5cclxuXHJcbiAgICAvLyBsZWZ0IHRvcFxyXG4gICAgdFtzaXplKytdID0gb2JqZWN0Lng7XHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QueTtcclxuICAgIHRbc2l6ZSsrXSA9IHo7XHJcbiAgICB0W3NpemUrK10gPSB0ZXhDb29yZC5sO1xyXG4gICAgdFtzaXplKytdID0gdGV4Q29vcmQudDtcclxuICAgIHRbc2l6ZSsrXSA9IHM7XHJcblxyXG4gICAgLy8gcmlnaHQgYm90dG9tXHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QucmlnaHQ7XHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QuYm90dG9tO1xyXG4gICAgdFtzaXplKytdID0gejtcclxuICAgIHRbc2l6ZSsrXSA9IHRleENvb3JkLnI7XHJcbiAgICB0W3NpemUrK10gPSB0ZXhDb29yZC5iO1xyXG4gICAgdFtzaXplKytdID0gcztcclxuICAgIFxyXG4gICAgLy8gcmlnaHQgdG9wXHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QucmlnaHQ7XHJcbiAgICB0W3NpemUrK10gPSBvYmplY3QudG9wO1xyXG4gICAgdFtzaXplKytdID0gejtcclxuICAgIHRbc2l6ZSsrXSA9IHRleENvb3JkLnI7XHJcbiAgICB0W3NpemUrK10gPSB0ZXhDb29yZC50O1xyXG4gICAgdFtzaXplKytdID0gcztcclxuXHJcbiAgICB0aGlzLnNpemUgPSBzaXplO1xyXG4gICAgdGhpcy52ZXJ0aWNlcyArPSA2O1xyXG4gIH1cclxuICBcclxuICBjbGVhcigpIHtcclxuICAgIHRoaXMuc2l6ZSA9IDA7XHJcbiAgICB0aGlzLnZlcnRpY2VzID0gMDtcclxuICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci9idWZmZXIuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IEJ1ZmZlciBmcm9tICcuL2J1ZmZlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQcm9ncmFtIHtcclxuICBjb25zdHJ1Y3RvcihnbCwgdmVydGV4U291cmNlLCBmcmFnbWVudFNvdXJjZSkge1xyXG4gICAgY29uc3QgdmVydGV4U2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLlZFUlRFWF9TSEFERVIpO1xyXG4gICAgY29uc3QgZnJhZ21lbnRTaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTtcclxuICAgIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNvdXJjZSk7XHJcbiAgICBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U291cmNlKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgIGdsLmNvbXBpbGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgY29uc3QgcHJvZ3JhbSA9IHRoaXMubmF0aXZlID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xyXG4gICAgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7XHJcbiAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgZnJhZ21lbnRTaGFkZXIpO1xyXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XHJcbiAgICBnbC5kZWxldGVTaGFkZXIodmVydGV4U2hhZGVyKTtcclxuICAgIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XHJcblxyXG4gICAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyKCk7XHJcbiAgfVxyXG5cclxuICBwcmVwYXJlKCkge1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsO1xyXG4gICAgY29uc3QgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7IC8vIG1heWJlIGl0IGRvZXNuJ3QgbmVlZCB0byBjcmVhdGUgaXQgZXZlcnkgdGltZVxyXG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IC8vIGRvbid0IGJpbmQgaWYgYm91bmQ/XHJcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXIsIGdsLlNUQVRJQ19EUkFXKTsgLy8gbWF5YmUgZHluYW1pYyBhbmQgc3ViIGRhdGEgaXMgcXVpY2tlclxyXG4gICAgZ2wudXNlUHJvZ3JhbSh0aGlzLm5hdGl2ZSk7IC8vIHRvZG8gcHJvZ3JhbSBtYW5hZ2VyIHNob3VsZCBjaGVjayBjdXJyZW50IHByb2dyYW0gaXMgdXNlZCBhbHJlYWR5XHJcbiAgICAvLyB3dGZcclxuICB9XHJcbn1cclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZW5kZXJlci9wcm9ncmFtTWFuYWdlci9wcm9ncmFtLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFRleCB7XHJcbiAgY29uc3RydWN0b3IoZ2wpIHtcclxuICAgIHRoaXMuZ2wgPSBnbDtcclxuICAgIHRoaXMuc2xvdHMgPSBbbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbF07XHJcbiAgfVxyXG5cclxuICBiaW5kKHRleHR1cmUpIHtcclxuICAgIGNvbnN0IHNsb3RzID0gdGhpcy5zbG90cztcclxuICAgIGxldCBpbmRleCA9IHNsb3RzLmluZGV4T2YodGV4dHVyZSk7XHJcblxyXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xyXG4gICAgICBpbmRleCA9IHNsb3RzLmluZGV4T2YobnVsbCk7XHJcbiAgICAgIHNsb3RzW2luZGV4XSA9IHRleHR1cmU7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBnbCA9IHRoaXMuZ2w7XHJcbiAgICAgIGNvbnN0IHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbFtgVEVYVFVSRSR7aW5kZXh9YF0pO1xyXG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgpO1xyXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgdGV4dHVyZS5pbWFnZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG4gIH1cclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3JlbmRlcmVyL3Byb2dyYW1NYW5hZ2VyL3RleC5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBOzs7OztBQ2hFQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDM0JBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7O0FDTEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7QUMxQ0E7Ozs7OztBQ0FBOzs7Ozs7O0FDQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUNyRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7O0EiLCJzb3VyY2VSb290IjoiIn0=